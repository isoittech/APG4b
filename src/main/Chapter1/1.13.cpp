#include <bits/stdc++.h>
using namespace std;

int main()
{
  // ■ 要素の追加
  // 配列は文字列のように+=で要素を追加することはできません。
  // 代わりに配列変数.push_backを使えば、配列の末尾に要素を追加することができます。
  vector<int> vec = {1, 2, 3};

  vec.push_back(10); // 末尾に10を追加

  // vecの全要素を出力
  for (int i = 0; i < vec.size(); i++)
  {
    cout << vec.at(i) << endl;
  }

  // ■ vector以外の配列
  // C++にはvector以外にも配列の書き方があります。次の3つの配列の書き方はほとんど同じ意味です。

  vector<int> dataArray1(3); // vectorによる配列
  int dataArray2[3];         // Cの配列
  array<int, 3> dataArray3;  // arrayによる配列

  // ■ atを使わないi番目の要素へのアクセス
  // 今まで配列の要素を指定するときは配列変数.at(添字)と書いてきましたが、配列変数[添字]でも同じことができます。
  // ただし、この書き方は範囲外の添字を指定してしまったときにエラーメッセージを表示してくれず、何が原因でプログラムが正しく動いていないのかがわかりにくいので、配列変数.at(添字)の書き方を使うようにしましょう。

  // ■ 要素の削除
  // 配列変数.pop_backを使えば配列の末尾の要素を削除することもできます。
  vector<int> vec2 = {1, 2, 3};
  vec2.pop_back(); // 末尾の要素を削除
  // vecの全要素を出力
  for (int i = 0; i < vec2.size(); i++)
  {
    cout << vec2.at(i) << endl;
  }

  // ■  配列同士の比較
  // 配列変数同士は==で比較することができます。
  // ==では2つの配列の全要素が一致していたとき、条件式は真になります。
  // ただし、比較する際はどちらも「配列変数」である必要があり、vec == { 1, 2, 3 }のようには書けないことに注意しましょう。
  vector<int> vec3_1 = {1, 2, 3};
  vector<int> vec3_2 = {1, 2, 3};

  if (vec3_1 == vec3_2)
  {
    cout << "OK" << endl;
  }

  /*
  ↓これはコンパイルエラーになる
  if (vec1 == { 1, 2, 3 }) {
    cout << "NG" << endl;
  }
  */

  //  ■ 配列の初期化その2
  // 配列の初期化は次のように書くこともできます。
  // vector<型> 配列変数 = vector<型>(要素数, 初期値);
  // この書き方はすでに宣言してある配列変数を上書きするときにも使えます。
  // 次の例では{10, 10, 10}で初期化してある変数を100要素の配列{2, 2, ... , 2, 2}で上書きしています。
  vector<int> vec4(3, 10);    // {10, 10, 10} で初期化
  vec4 = vector<int>(100, 2); // 100要素の配列 {2, 2, ... , 2, 2} で上書き
  cout << vec4.at(99) << endl;
}
